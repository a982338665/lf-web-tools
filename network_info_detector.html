<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç½‘ç»œä¿¡æ¯æ£€æµ‹å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 8px;
            font-size: 14px;
            overflow-x: auto;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.4em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .main-table-container {
            background: #fff;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 0;
            font-size: 0.9em;
        }

        .info-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 8px;
            text-align: left;
            font-weight: bold;
            border-bottom: 1px solid #5a6fd8;
            font-size: 0.95em;
        }

        .info-table td {
            padding: 4px 8px;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
        }

        .info-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .info-table tr:hover {
            background-color: #e3f2fd;
        }

        .info-table .label-col {
            font-weight: bold;
            color: #495057;
            width: 25%;
            background-color: rgba(102, 126, 234, 0.05);
        }

        .info-table .value-col {
            color: #007bff;
            font-family: 'Courier New', monospace;
            width: 25%;
        }

        .section-title {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            text-align: center;
            font-size: 1.0em;
            font-weight: bold;
        }

        .compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .btn-container {
            text-align: center;
            margin: 8px 0;
        }

        .footer {
            text-align: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e9ecef;
            color: #6c757d;
            font-size: 0.75em;
        }


        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .status-enabled {
            background-color: #d4edda;
            color: #155724;
        }

        .status-disabled {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status-unknown {
            background-color: #fff3cd;
            color: #856404;
        }

        .mac-address {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #28a745;
        }

        .ip-address {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #007bff;
        }

        .multi-line-ip {
            line-height: 1.6;
            word-break: break-all;
        }

        .loading {
            color: #ffc107;
        }

        .error {
            color: #dc3545;
        }

        .success {
            color: #28a745;
        }

        .refresh-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 15px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
            margin: 0 3px;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.6);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .online {
            background-color: #28a745;
        }

        .offline {
            background-color: #dc3545;
        }

        .warning {
            background-color: #ffc107;
        }

        .user-agent {
            font-size: 0.8em;
            word-break: break-all;
        }

        .port-note {
            text-align: center;
            font-size: 0.75em;
            color: #6c757d;
            padding: 8px;
        }

        @media (max-width: 768px) {
            .compact-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.3em;
                margin-bottom: 15px;
            }

            .container {
                padding: 15px;
            }

            .info-table {
                font-size: 0.85em;
            }

            .info-table th,
            .info-table td {
                padding: 5px 8px;
            }

            .refresh-btn {
                padding: 8px 20px;
                font-size: 0.85em;
                margin: 5px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 10px;
            }

            h1 {
                font-size: 1.2em;
            }

            .info-table {
                font-size: 0.8em;
            }

            .main-table-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>ğŸŒ ç½‘ç»œä¿¡æ¯æ£€æµ‹å™¨</h1>

    <div class="btn-container">
        <button class="refresh-btn" onclick="refreshAllInfo()">ğŸ”„ åˆ·æ–°æ‰€æœ‰ä¿¡æ¯</button>
    </div>

    <!-- ä¸»è¦ç½‘ç»œä¿¡æ¯è¡¨æ ¼ -->
    <div class="main-table-container">
        <table class="info-table">
            <thead>
            <tr>
                <th colspan="4" class="section-title">ğŸŒ ç½‘ç»œä¸ç³»ç»Ÿä¿¡æ¯æ€»è§ˆ</th>
            </tr>
            <tr>
                <th>IPåœ°å€ä¿¡æ¯</th>
                <th>ç½‘ç»œçŠ¶æ€</th>
                <th>ç³»ç»Ÿä¿¡æ¯</th>
                <th>DNS/è¿æ¥ä¿¡æ¯</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td class="label-col">æœ¬åœ°IPåœ°å€</td>
                <td class="label-col">è¿æ¥çŠ¶æ€</td>
                <td class="label-col">æµè§ˆå™¨</td>
                <td class="label-col">DNSæœåŠ¡å™¨</td>
            </tr>
            <tr>
                <td class="value-col loading" id="localIP">æ£€æµ‹ä¸­...</td>
                <td class="value-col" id="networkStatus"><span class="status-indicator online"></span>åœ¨çº¿</td>
                <td class="value-col" id="browser">-</td>
                <td class="value-col loading" id="dnsServers">æ£€æµ‹ä¸­...</td>
            </tr>
            <tr>
                <td class="label-col">å…¬ç½‘IPåœ°å€</td>
                <td class="label-col">è¿æ¥ç±»å‹</td>
                <td class="label-col">æ“ä½œç³»ç»Ÿ</td>
                <td class="label-col">DNSè§£ææ—¶é—´</td>
            </tr>
            <tr>
                <td class="value-col loading" id="publicIP">æ£€æµ‹ä¸­...</td>
                <td class="value-col" id="connectionType">æ£€æµ‹ä¸­...</td>
                <td class="value-col" id="platform">-</td>
                <td class="value-col loading" id="dnsTime">æµ‹è¯•ä¸­...</td>
            </tr>
            <tr>
                <td class="label-col">ç½‘ç»œé€Ÿåº¦</td>
                <td class="label-col">å»¶è¿Ÿ</td>
                <td class="label-col">å±å¹•åˆ†è¾¨ç‡</td>
                <td class="label-col">ä¸»æœºå</td>
            </tr>
            <tr>
                <td class="value-col" id="networkSpeed">æ£€æµ‹ä¸­...</td>
                <td class="value-col loading" id="latency">æµ‹è¯•ä¸­...</td>
                <td class="value-col" id="screenRes">-</td>
                <td class="value-col" id="hostname">-</td>
            </tr>
            <tr>
                <td class="label-col">-</td>
                <td class="label-col">-</td>
                <td class="label-col">ç”¨æˆ·ä»£ç†</td>
                <td class="label-col">åŸŸå</td>
            </tr>
            <tr>
                <td class="label-col">-</td>
                <td class="label-col">-</td>
                <td class="value-col user-agent" id="userAgent">-</td>
                <td class="value-col" id="domain">-</td>
            </tr>
            </tbody>
        </table>
    </div>

    <!-- ç«¯å£å’ŒWebRTCä¿¡æ¯è¡¨æ ¼ -->
    <div class="compact-grid">
        <div class="main-table-container">
            <table class="info-table">
                <thead>
                <tr>
                    <th colspan="2" class="section-title">ğŸ”Œ æœ¬åœ°ç«¯å£æ£€æµ‹ä¿¡æ¯</th>
                </tr>
                <tr>
                    <th>ç«¯å£/æœåŠ¡/åè®®</th>
                    <th>çŠ¶æ€</th>
                </tr>
                </thead>
                <tbody id="portTableBody">
                <tr>
                    <td colspan="2" style="text-align: center; color: #ffc107;">æ­£åœ¨æ£€æµ‹å¸¸ç”¨ç«¯å£...</td>
                </tr>
                </tbody>
            </table>
        </div>

        <div class="main-table-container">
            <table class="info-table">
                <thead>
                <tr>
                    <th colspan="2" class="section-title">ğŸ”— WebRTCè¿æ¥ä¿¡æ¯</th>
                </tr>
                <tr>
                    <th>é¡¹ç›®</th>
                    <th>å€¼</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td class="label-col">STUNæœåŠ¡å™¨</td>
                    <td class="value-col" id="stunServer">stun.l.google.com:19302</td>
                </tr>
                <tr>
                    <td class="label-col">ICEå€™é€‰</td>
                    <td class="value-col loading" id="iceCandidates">æ”¶é›†ä¸­...</td>
                </tr>
                <tr>
                    <td class="label-col">æœ¬åœ°å€™é€‰</td>
                    <td class="value-col loading" id="localCandidates">æ”¶é›†ä¸­...</td>
                </tr>
                <tr>
                    <td class="label-col">ç½‘ç»œæ¥å£</td>
                    <td class="value-col loading" id="networkInterfaces">æ£€æµ‹ä¸­...</td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="footer">
        <p>ğŸ’¡ æç¤ºï¼šå¤–ç½‘IPé€šè¿‡WebRTC STUNæœåŠ¡å™¨è·å–ï¼Œåœ°ç†ä½ç½®ä½¿ç”¨å¤šä¸ªAPIå¤‡é€‰æŸ¥è¯¢</p>
        <p>ğŸ”’ æ­¤å·¥å…·ä»…åœ¨æœ¬åœ°è¿è¡Œï¼Œä¸ä¼šæ”¶é›†æˆ–ä¸Šä¼ ä»»ä½•æ•°æ®</p>
        <p>âš¡ æœ¬åœ°ç«¯å£æ£€æµ‹ä½¿ç”¨WebSocketã€HTTPã€Imageç­‰å¤šç§æ–¹æ³•ç»¼åˆåˆ¤æ–­</p>
    </div>
</div>

<script>
    // å…¨å±€å˜é‡
    let localIPAddresses = [];
    let publicIPInfo = {};

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function () {
        initNetworkInfo();
    });

    // åˆå§‹åŒ–æ‰€æœ‰ç½‘ç»œä¿¡æ¯æ£€æµ‹
    function initNetworkInfo() {
        getBrowserInfo();
        getNetworkStatus();
        getLocalIPs();  // ç°åœ¨è¿™ä¸ªå‡½æ•°ä¼šåŒæ—¶è·å–æœ¬åœ°IPå’Œå¤–ç½‘IPï¼Œå¹¶æŸ¥è¯¢ä½ç½®
        testLatency();
        getDNSInfo();
        checkCommonPorts();
        getWebRTCInfo();
    }

    // è·å–æµè§ˆå™¨ä¿¡æ¯
    function getBrowserInfo() {
        const userAgent = navigator.userAgent;
        document.getElementById('userAgent').textContent = userAgent;

        // è§£ææµè§ˆå™¨ç±»å‹ - æ”¹è¿›æ£€æµ‹é¡ºåºï¼Œä¼˜å…ˆæ£€æµ‹ç‰¹æ®Šæƒ…å†µ
        let browserName = "Unknown";

        // Edge æ£€æµ‹ï¼ˆæ–°ç‰ˆå’Œæ—§ç‰ˆï¼‰
        if (userAgent.indexOf("Edg/") > -1 || userAgent.indexOf("Edge/") > -1) {
            browserName = "Edge";
        }
        // Internet Explorer æ£€æµ‹
        else if (userAgent.indexOf("MSIE") > -1 || userAgent.indexOf("Trident/") > -1) {
            browserName = "Internet Explorer";
        }
        // Chrome æ£€æµ‹ï¼ˆéœ€è¦æ’é™¤Edgeå’Œå…¶ä»–åŸºäºChromiumçš„æµè§ˆå™¨ï¼‰
        else if (userAgent.indexOf("Chrome") > -1 && userAgent.indexOf("Safari") > -1) {
            browserName = "Chrome";
        }
        // Firefox æ£€æµ‹
        else if (userAgent.indexOf("Firefox") > -1) {
            browserName = "Firefox";
        }
        // Safari æ£€æµ‹ï¼ˆéœ€è¦æ’é™¤Chromeï¼‰
        else if (userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1) {
            browserName = "Safari";
        }
        // Opera æ£€æµ‹
        else if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) {
            browserName = "Opera";
        }

        document.getElementById('browser').textContent = browserName;
        document.getElementById('platform').textContent = navigator.platform || '-';

        // å±å¹•åˆ†è¾¨ç‡æ£€æµ‹
        try {
            document.getElementById('screenRes').textContent = `${screen.width} x ${screen.height}`;
        } catch (e) {
            document.getElementById('screenRes').textContent = '-';
        }
    }

    // è·å–ç½‘ç»œçŠ¶æ€
    function getNetworkStatus() {
        // æ£€æµ‹åœ¨çº¿çŠ¶æ€
        const updateOnlineStatus = () => {
            const statusEl = document.getElementById('networkStatus');
            if (navigator.onLine) {
                statusEl.innerHTML = '<span class="status-indicator online"></span>åœ¨çº¿';
            } else {
                statusEl.innerHTML = '<span class="status-indicator offline"></span>ç¦»çº¿';
            }
        };

        updateOnlineStatus();
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // è·å–è¿æ¥ç±»å‹
        if ('connection' in navigator) {
            const conn = navigator.connection;
            const connType = conn.effectiveType || conn.type || 'æœªçŸ¥';
            const downlink = conn.downlink ? `${conn.downlink} Mbps` : 'æœªçŸ¥';

            document.getElementById('connectionType').textContent = connType;
            document.getElementById('networkSpeed').textContent = downlink;
        } else {
            document.getElementById('connectionType').textContent = 'æµè§ˆå™¨ä¸æ”¯æŒ';
            document.getElementById('networkSpeed').textContent = 'æµè§ˆå™¨ä¸æ”¯æŒ';
        }
    }

    // è·å–æœ¬åœ°IPå’Œå¤–ç½‘IPåœ°å€ï¼ˆé€šè¿‡WebRTCï¼‰
    function getLocalIPs() {
        const configuration = {
            iceServers: [
                {urls: 'stun:stun.l.google.com:19302'},
                {urls: 'stun:stun1.l.google.com:19302'},
                {urls: 'stun:stun2.l.google.com:19302'}
            ]
        };

        const pc = new RTCPeerConnection(configuration);
        const localIps = new Set();
        const publicIps = new Set();

        pc.createDataChannel("");

        pc.onicecandidate = function (event) {
            if (event.candidate) {
                const candidate = event.candidate.candidate;
                const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
                const ipMatch = candidate.match(ipRegex);

                if (ipMatch) {
                    const ip = ipMatch[1];

                    // åŒºåˆ†æœ¬åœ°IPå’Œå¤–ç½‘IP
                    if (candidate.includes('typ host')) {
                        // æœ¬åœ°ç½‘ç»œæ¥å£IP
                        if (!ip.startsWith('127.') && !ip.startsWith('169.254.')) {
                            localIps.add(ip);
                            localIPAddresses = Array.from(localIps);
                            document.getElementById('localIP').textContent = localIPAddresses.join(', ') || '-';
                            document.getElementById('localIP').className = 'value-col success';
                        }
                    } else if (candidate.includes('typ srflx')) {
                        // STUNæœåŠ¡å™¨åå°„çš„å¤–ç½‘IP
                        publicIps.add(ip);
                        const publicIpsArray = Array.from(publicIps);

                        // å¼‚æ­¥è·å–ä½ç½®å¹¶æ ¼å¼åŒ–æ˜¾ç¤º
                        updatePublicIPDisplay(publicIpsArray);
                    }
                }
            }
        };

        pc.createOffer().then(offer => pc.setLocalDescription(offer));

        // è¶…æ—¶å¤„ç†
        setTimeout(() => {
            if (localIPAddresses.length === 0) {
                document.getElementById('localIP').textContent = '-';
                document.getElementById('localIP').className = 'value-col';
            }
            if (publicIps.size === 0) {
                // å¦‚æœWebRTCè·å–ä¸åˆ°å¤–ç½‘IPï¼Œfallbackåˆ°APIæ–¹å¼
                getPublicIPFallback();
            }
            pc.close();
        }, 8000);
    }

    // æ ¹æ®IPåœ°å€è·å–ä½ç½®ä¿¡æ¯ï¼ˆä¼˜å…ˆçº§æ¨¡å¼ï¼‰
    async function getIPLocation(ip) {
        try {
            // ä½¿ç”¨å¤šä¸ªAPIæœåŠ¡ï¼ŒæŒ‰ä¼˜å…ˆçº§é¡ºåºæŸ¥è¯¢
            const apiTests = [
                // ipinfo.io - å›½å†…ä¸å‡†ï¼Œå›½å¤–å‡†

                // ipapi.co - å¤‡é€‰APIï¼Œç²¾ç¡®åº¦è¾ƒé«˜
                {
                    name: 'ipapi.co',
                    url: `https://ipapi.co/${ip}/json/`,
                    parser: (data) => {
                        if (data.city && data.region && data.country_name) {
                            return `${data.city}, ${data.region}, ${data.country_name}`;
                        } else if (data.country_name) {
                            return data.country_name;
                        }
                        return null;
                    }
                },
                // ipgeolocation.io - å¤‡é€‰API
                {
                    name: 'ipgeolocation.io',
                    url: `https://api.ipgeolocation.io/v2/ipgeo?apiKey=c12f4e421c214d7ea0dbba0f34111261&ip=${ip}`,
                    parser: (data) => {
                        if (data.location.city && data.location.state_prov && data.location.country_name) {
                            return `${data.location.city}, ${data.location.state_prov}, ${data.location.country_name}`;
                        } else if (data.location.country_name) {
                            return data.location.country_name;
                        }
                        return null;
                    }
                },
                // freeipapi.com - å¤‡é€‰API
                {
                    name: 'freeipapi.com',
                    url: `https://free.freeipapi.com/api/json/${ip}`,
                    parser: (data) => {
                        if (data.cityName && data.regionName && data.countryName) {
                            return `${data.cityName}, ${data.regionName}, ${data.countryName}`;
                        } else if (data.countryName) {
                            return data.countryName;
                        }
                        return null;
                    }
                },
                {
                    name: 'ipinfo.io',
                    url: `https://ipinfo.io/${ip}/json`,
                    parser: (data) => {
                        if (data.city && data.region && data.country) {
                            return `${data.city}, ${data.region}, ${data.country}`;
                        } else if (data.country) {
                            return data.country;
                        }
                        return null;
                    }
                },
                // ipip.net - å›½å†…å‡†ï¼Œå›½å¤–ä¸å‡†
                {
                    name: 'ipip.net',
                    url: `http://myip.ipip.net`,
                    parser: (data) => {
                        return data.split("æ¥è‡ªäºï¼š");
                    }
                },

            ];

            console.log(`å¼€å§‹æŸ¥è¯¢IP ${ip} çš„ä½ç½®ä¿¡æ¯...`);

            // æŒ‰ä¼˜å…ˆçº§é¡ºåºå°è¯•æ¯ä¸ªAPI
            for (const apiTest of apiTests) {
                try {
                    console.log(`ğŸ” å°è¯• ${apiTest.name}...`);

                    const response = await fetch(apiTest.url, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-cache',
                        signal: AbortSignal.timeout(5000), // 5ç§’è¶…æ—¶
                        // headers: {
                        //     'Accept': 'application/json'
                        // }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    const location = apiTest.parser(data);

                    if (location) {
                        console.log(`âœ… ${apiTest.name} æˆåŠŸè¿”å›ä½ç½®:`, location);
                        return location;
                    } else {
                        console.log(`âš ï¸ ${apiTest.name} è¿”å›æ•°æ®ä¸å®Œæ•´`);
                    }

                } catch (e) {
                    console.log(`âŒ ${apiTest.name} æŸ¥è¯¢å¤±è´¥:`, e.message);
                    continue;
                }
            }

            // å¦‚æœæ‰€æœ‰APIéƒ½å¤±è´¥
            console.warn('æ‰€æœ‰IPä½ç½®æŸ¥è¯¢APIéƒ½å¤±è´¥');
            return 'ä½ç½®æœªçŸ¥';

        } catch (error) {
            console.error('IPä½ç½®æŸ¥è¯¢å‡ºé”™:', error);
            return 'ä½ç½®æœªçŸ¥';
        }
    }

    // æ›´æ–°å…¬ç½‘IPæ˜¾ç¤ºï¼ˆåŒ…å«ä½ç½®ä¿¡æ¯ï¼‰
    async function updatePublicIPDisplay(publicIpsArray) {
        try {
            const formattedIPs = [];

            for (const ip of publicIpsArray) {
                console.log(`\nğŸ” å¼€å§‹æŸ¥è¯¢IP ${ip} çš„ä½ç½®ä¿¡æ¯...`);
                const location = await getIPLocation(ip);
                formattedIPs.push(`${ip}ï¼ˆ${location}ï¼‰`);
                console.log(`âœ… IP ${ip} ä½ç½®æŸ¥è¯¢å®Œæˆ: ${location}\n`);
            }

            // è®¾ç½®æ˜¾ç¤ºæ ·å¼
            const element = document.getElementById('publicIP');
            element.style.whiteSpace = 'pre-line';
            element.textContent = formattedIPs.join('\n');
            element.className = 'value-col success multi-line-ip';

            console.log('ğŸ‰ æ‰€æœ‰IPä½ç½®æŸ¥è¯¢å®Œæˆï¼');

        } catch (error) {
            console.error('ä½ç½®æŸ¥è¯¢è¿‡ç¨‹å‡ºé”™:', error);
            // å¦‚æœä½ç½®è·å–å¤±è´¥ï¼Œæ˜¾ç¤ºä¸å¸¦ä½ç½®çš„æ ¼å¼
            const formattedIPs = publicIpsArray.map(ip => `${ip}ï¼ˆä½ç½®æœªçŸ¥ï¼‰`).join('\n');
            const element = document.getElementById('publicIP');
            element.style.whiteSpace = 'pre-line';
            element.textContent = formattedIPs;
            element.className = 'value-col success multi-line-ip';
        }
    }

    // WebRTCè·å–ä¸åˆ°å¤–ç½‘IPæ—¶çš„åå¤‡æ–¹æ¡ˆ
    async function getPublicIPFallback() {
        try {
            // ä½¿ç”¨å¤šä¸ªAPIæœåŠ¡ä»¥æé«˜å¯é æ€§
            const apis = [
                'https://ipapi.co/json/',
                'https://ipinfo.io/json',
                'https://api.ipify.org?format=json'
            ];

            for (const api of apis) {
                try {
                    const response = await fetch(api);
                    const data = await response.json();

                    if (data.ip) {
                        // ä½¿ç”¨ç»Ÿä¸€çš„æ˜¾ç¤ºæ–¹æ³•
                        await updatePublicIPDisplay([data.ip]);
                        publicIPInfo = data;
                        break;
                    }
                } catch (e) {
                    continue;
                }
            }

            // å¦‚æœæ‰€æœ‰APIéƒ½å¤±è´¥
            const currentText = document.getElementById('publicIP').textContent;
            if (!currentText || currentText === 'æ£€æµ‹ä¸­...' || currentText === '-') {
                throw new Error('æ‰€æœ‰APIéƒ½æ— æ³•è®¿é—®');
            }

        } catch (error) {
            document.getElementById('publicIP').textContent = '-';
            document.getElementById('publicIP').className = 'value-col';
        }
    }

    // ä¿æŒåŸæœ‰çš„getPublicIPå‡½æ•°ä½œä¸ºå…¼å®¹æ€§æ¥å£
    async function getPublicIP() {
        // ç°åœ¨ä¸»è¦é€šè¿‡WebRTCè·å–ï¼Œè¿™é‡Œä½œä¸ºåå¤‡
        return;
    }

    // æµ‹è¯•ç½‘ç»œå»¶è¿Ÿ
    async function testLatency() {
        try {
            const start = performance.now();
            await fetch('https://www.google.com/favicon.ico', {
                mode: 'no-cors',
                cache: 'no-cache'
            });
            const end = performance.now();
            const latency = Math.round(end - start);

            document.getElementById('latency').textContent = `${latency} ms`;
            document.getElementById('latency').className = `value-col ${latency < 100 ? 'success' : latency < 300 ? 'warning' : 'error'}`;
        } catch (error) {
            document.getElementById('latency').textContent = '-';
            document.getElementById('latency').className = 'value-col';
        }
    }

    // è·å–DNSä¿¡æ¯
    async function getDNSInfo() {
        try {
            // æµ‹è¯•DNSè§£ææ—¶é—´
            const start = performance.now();
            await fetch('https://www.google.com', {mode: 'no-cors'});
            const end = performance.now();
            const dnsTime = Math.round(end - start);

            document.getElementById('dnsTime').textContent = `${dnsTime} ms`;
            document.getElementById('dnsTime').className = 'value-col success';

            // è·å–ä¸»æœºåå’ŒåŸŸå
            document.getElementById('hostname').textContent = window.location.hostname || 'localhost';
            document.getElementById('domain').textContent = window.location.host || 'file://';

            // DNSæœåŠ¡å™¨ï¼ˆæµè§ˆå™¨æ— æ³•ç›´æ¥è·å–ï¼‰
            document.getElementById('dnsServers').textContent = '-';
            document.getElementById('dnsServers').className = 'value-col';

        } catch (error) {
            document.getElementById('dnsTime').textContent = '-';
            document.getElementById('dnsTime').className = 'value-col';
            document.getElementById('dnsServers').textContent = '-';
            document.getElementById('dnsServers').className = 'value-col';
        }
    }

    // æ£€æµ‹æœ¬åœ°ç«¯å£ï¼ˆå¤šç§æ–¹æ³•ç»¼åˆæ£€æµ‹ï¼‰
    async function checkCommonPorts() {
        const localPorts = [
            {port: 80, name: 'NGINX', protocol: 'HTTP/WEBSOCKET', type: 'web'},
            {port: 3000, name: 'Node.js Dev', protocol: 'HTTP/WEBSOCKET', type: 'dev'},
            {port: 5000, name: 'Flask/Dev', protocol: 'HTTP/WEBSOCKET', type: 'dev'},
            {port: 8000, name: 'Python HTTP', protocol: 'HTTP/WEBSOCKET', type: 'dev'},
            {port: 8080, name: 'HTTP-Alt', protocol: 'HTTP/WEBSOCKET', type: 'web'},
            {port: 9000, name: 'Dev Server', protocol: 'HTTP/WEBSOCKET', type: 'dev'},
        ];

        const portTableBody = document.getElementById('portTableBody');
        portTableBody.innerHTML = '';

        // åˆ›å»ºåˆå§‹è¡Œï¼Œæ˜¾ç¤ºæ£€æµ‹çŠ¶æ€
        localPorts.forEach(portInfo => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="label-col">ç«¯å£ ${portInfo.port} (${portInfo.name}/${portInfo.protocol})</td>
                <td class="value-col loading" id="port_${portInfo.port}">æ£€æµ‹ä¸­...</td>
            `;
            portTableBody.appendChild(row);
        });

        console.log('ğŸš€ å¼€å§‹æ£€æµ‹æœ¬åœ°ç«¯å£çŠ¶æ€...');
        console.log('ğŸ’¡ æç¤ºï¼šè¯·æ‰“å¼€æµè§ˆå™¨å¼€å‘è€…å·¥å…·(F12)æŸ¥çœ‹è¯¦ç»†æ£€æµ‹è¿‡ç¨‹');

        // å¹¶è¡Œæ£€æµ‹æ‰€æœ‰ç«¯å£
        const promises = localPorts.map(async (portInfo) => {
            const result = await detectLocalPort(portInfo.port, portInfo.protocol, portInfo.type);
            const element = document.getElementById(`port_${portInfo.port}`);

            if (result.status === 'open') {
                const protocolInfo = result.protocol ? `(${result.protocol})` : '';
                element.innerHTML = `<span class="status-indicator online"></span>${result.method}æ£€æµ‹åˆ°å¼€æ”¾ ${protocolInfo}`;
                element.className = 'value-col success';
            } else if (result.status === 'closed') {
                element.innerHTML = `<span class="status-indicator offline"></span>å…³é—­`;
                element.className = 'value-col error';
            } else {
                element.textContent = '-';
                element.className = 'value-col';
            }
        });

        // ç­‰å¾…æ‰€æœ‰æ£€æµ‹å®Œæˆ
        await Promise.allSettled(promises);

        // æ·»åŠ è¯´æ˜è¡Œ
        const noteRow = document.createElement('tr');
        noteRow.innerHTML = `
            <td colspan="2" class="port-note">
                ğŸ’¡ ä½¿ç”¨WebSocketã€HTTPã€Imageç­‰æ–¹æ³•æ£€æµ‹æœ¬åœ°ç«¯å£ | ğŸŸ¢å¼€æ”¾ ğŸ”´å…³é—­ - æ— æ³•ç¡®å®š<br>
                ğŸ”§ å¦‚æœæ£€æµ‹ç»“æœä¸å‡†ç¡®ï¼Œè¯·æŒ‰F12æŸ¥çœ‹æ§åˆ¶å°è¯¦ç»†æ—¥å¿—ï¼Œæˆ–å°è¯•åˆ·æ–°é¡µé¢
            </td>
        `;
        portTableBody.appendChild(noteRow);
    }

    // æ£€æµ‹æœ¬åœ°ç«¯å£çŠ¶æ€ï¼ˆç»¼åˆå¤šç§æ–¹æ³•ï¼‰
    async function detectLocalPort(port, protocol, type) {
        console.log(`ğŸ” æ£€æµ‹æœ¬åœ°ç«¯å£ ${port} (${protocol}, ç±»å‹: ${type})...`);

        // å¯¹äºwebå’Œdevç±»å‹çš„ç«¯å£ï¼Œä¼˜å…ˆä½¿ç”¨HTTPæ£€æµ‹
        if (type === 'web' || type === 'dev') {
            console.log(`ç«¯å£ ${port}: ä¼˜å…ˆä½¿ç”¨HTTPæ£€æµ‹...`);
            const httpResult = await testHTTP(port);
            if (httpResult.status === 'open') {
                console.log(`âœ… ç«¯å£ ${port}: HTTPæ£€æµ‹æˆåŠŸ!`);
                return {
                    status: httpResult.status,
                    method: 'HTTP',
                    protocol: httpResult.protocol
                };
            } else if (httpResult.status === 'closed') {
                console.log(`âŒ ç«¯å£ ${port}: HTTPæ£€æµ‹ç¡®è®¤å…³é—­`);
                return {status: httpResult.status, method: 'HTTP'};
            }
        }

        // æ–¹æ³•1: WebSocket è¿æ¥æµ‹è¯•
        console.log(`ç«¯å£ ${port}: å°è¯•WebSocketæ£€æµ‹...`);
        const wsResult = await testWebSocket(port);
        if (wsResult.status === 'open') {
            console.log(`âœ… ç«¯å£ ${port}: WebSocketæ£€æµ‹æˆåŠŸ!`);
            return {status: wsResult.status, method: 'WebSocket'};
        }

        // æ–¹æ³•2: åŸå§‹TCPè¿æ¥æµ‹è¯•
        console.log(`ç«¯å£ ${port}: å°è¯•TCPè¿æ¥æ£€æµ‹...`);
        const tcpResult = await testTCPConnection(port);
        if (tcpResult.status === 'open') {
            console.log(`âœ… ç«¯å£ ${port}: TCPè¿æ¥æ£€æµ‹æˆåŠŸ!`);
            return {status: tcpResult.status, method: 'TCP'};
        }

        // æ–¹æ³•3: å›¾ç‰‡åŠ è½½æµ‹è¯•ï¼ˆé€‚ç”¨äºHTTPæœåŠ¡ï¼‰
        console.log(`ç«¯å£ ${port}: å°è¯•ImageåŠ è½½æ£€æµ‹...`);
        const imgResult = await testImageLoad(port);
        if (imgResult.status === 'open') {
            console.log(`âœ… ç«¯å£ ${port}: Imageæ£€æµ‹æˆåŠŸ!`);
            return {status: imgResult.status, method: 'Image'};
        }

        // æ–¹æ³•4: Fetchè¿æ¥æµ‹è¯•
        console.log(`ç«¯å£ ${port}: å°è¯•Fetchæ£€æµ‹...`);
        const fetchResult = await testFetch(port);
        if (fetchResult.status === 'open') {
            console.log(`âœ… ç«¯å£ ${port}: Fetchæ£€æµ‹æˆåŠŸ!`);
            return {status: fetchResult.status, method: 'Fetch'};
        }

        // å¦‚æœæœ‰ä»»ä½•æ–¹æ³•æ˜ç¡®è¿”å›å…³é—­ï¼Œåˆ™è®¤ä¸ºå…³é—­
        if (wsResult.status === 'closed' || tcpResult.status === 'closed' ||
            imgResult.status === 'closed' || fetchResult.status === 'closed') {
            console.log(`âŒ ç«¯å£ ${port}: å¤šç§æ–¹æ³•ç¡®è®¤ç«¯å£å…³é—­`);
            return {status: 'closed', method: 'Multiple'};
        }

        console.log(`âš ï¸ ç«¯å£ ${port}: æ‰€æœ‰æ£€æµ‹æ–¹æ³•éƒ½æ— æ³•ç¡®å®šçŠ¶æ€`);
        return {status: 'unknown', method: 'Unknown'};
    }

    // WebSocket è¿æ¥æµ‹è¯•
    async function testWebSocket(port) {
        return new Promise((resolve) => {
            try {
                const ws = new WebSocket(`ws://localhost:${port}`);

                const timeout = setTimeout(() => {
                    ws.close();
                    resolve({status: 'unknown'});
                }, 3000);

                ws.onopen = () => {
                    clearTimeout(timeout);
                    ws.close();
                    console.log(`ç«¯å£ ${port}: WebSocketè¿æ¥æˆåŠŸ`);
                    resolve({status: 'open'});
                };

                ws.onerror = (error) => {
                    clearTimeout(timeout);
                    console.log(`ç«¯å£ ${port}: WebSocketè¿æ¥å¤±è´¥`);
                    resolve({status: 'closed'});
                };

            } catch (error) {
                console.log(`ç«¯å£ ${port}: WebSocketæµ‹è¯•å¼‚å¸¸`);
                resolve({status: 'unknown'});
            }
        });
    }

    // HTTP è¯·æ±‚æµ‹è¯•ï¼ˆåŒæ—¶å°è¯•HTTPå’ŒHTTPSï¼‰
    async function testHTTP(port) {
        // å…ˆå°è¯•HTTP
        const httpResult = await testSingleHTTP(port, 'http');
        if (httpResult.status === 'open') {
            return {status: 'open', protocol: 'HTTP'};
        }
        // å†å°è¯•HTTPS
        const httpsResult = await testSingleHTTP(port, 'https');
        if (httpsResult.status === 'open') {
            return {status: 'open', protocol: 'HTTPS'};
        }

        // å¦‚æœä¸¤ä¸ªéƒ½å¤±è´¥ï¼Œè¿”å›è¾ƒæ˜ç¡®çš„ç»“æœ
        if (httpResult.status === 'closed' || httpsResult.status === 'closed') {
            return {status: 'closed'};
        }

        return {status: 'unknown'};
    }

    // å•ä¸ªåè®®çš„HTTPæµ‹è¯•
    async function testSingleHTTP(port, protocol) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 8000); // å¢åŠ åˆ°8ç§’

            // å°è¯•å¤šä¸ªåœ°å€ï¼šlocalhost å’Œ 127.0.0.1
            const addresses = ['localhost', '127.0.0.1'];

            for (const address of addresses) {
                try {
                    console.log(`ç«¯å£ ${port}: å°è¯• ${protocol}://${address}:${port}`);
                    const response = await fetch(`${protocol}://${address}:${port}`, {
                        method: 'GET',
                        mode: 'no-cors', // no-corsæ¨¡å¼ä¸‹ï¼ŒæˆåŠŸè¯·æ±‚ä¸ä¼šæŠ›å‡ºå¼‚å¸¸
                        signal: controller.signal,
                        cache: 'no-cache'
                    });
                    clearTimeout(timeoutId);

                    console.log(`ç«¯å£ ${port}: ${protocol.toUpperCase()}è¯·æ±‚æˆåŠŸ (${address})ï¼ŒçŠ¶æ€:`, response.type);
                    // no-corsæ¨¡å¼ä¸‹ï¼Œå¦‚æœè¯·æ±‚æˆåŠŸï¼Œresponse.typeä¼šæ˜¯'opaque'

                    if (response.type === 'opaque' || response.ok) {
                        return {status: 'open'};
                    }
                } catch (addrError) {
                    console.log(`ç«¯å£ ${port}: ${protocol.toUpperCase()} ${address} å¤±è´¥:`, addrError.message);
                    continue; // å°è¯•ä¸‹ä¸€ä¸ªåœ°å€
                }
            }

            clearTimeout(timeoutId);
            return {status: 'unknown'};

        } catch (error) {
            console.log(`ç«¯å£ ${port}: ${protocol.toUpperCase()}è¯·æ±‚å¼‚å¸¸:`, error.name, error.message);

            if (error.name === 'AbortError') {
                console.log(`ç«¯å£ ${port}: ${protocol.toUpperCase()}è¯·æ±‚è¶…æ—¶`);
                return {status: 'unknown'};
            }

            // æ›´ç²¾ç¡®çš„é”™è¯¯åˆ†æ
            const errorMessage = error.message.toLowerCase();

            if (errorMessage.includes('connection refused') ||
                errorMessage.includes('connection reset') ||
                errorMessage.includes('network error') ||
                errorMessage.includes('failed to fetch')) {

                // è¿›ä¸€æ­¥åŒºåˆ†æ˜¯ç«¯å£å…³é—­è¿˜æ˜¯å…¶ä»–ç½‘ç»œé—®é¢˜
                if (errorMessage.includes('refused')) {
                    console.log(`ç«¯å£ ${port}: ${protocol.toUpperCase()}è¿æ¥è¢«æ‹’ç» - ç«¯å£å…³é—­`);
                    return {status: 'closed'};
                } else {
                    console.log(`ç«¯å£ ${port}: ${protocol.toUpperCase()}ç½‘ç»œé”™è¯¯ - çŠ¶æ€æœªçŸ¥`);
                    return {status: 'unknown'};
                }
            }

            // å¯¹äºå…¶ä»–ç±»å‹çš„é”™è¯¯ï¼Œè®¤ä¸ºæ˜¯ç«¯å£ç›¸å…³é—®é¢˜
            console.log(`ç«¯å£ ${port}: ${protocol.toUpperCase()}å…¶ä»–é”™è¯¯ï¼Œå¯èƒ½ç«¯å£å…³é—­`);
            return {status: 'closed'};
        }
    }

    // æ•°æ®åº“ç«¯å£æ£€æµ‹ï¼ˆä¸“ç”¨äºMySQLã€PostgreSQLç­‰ï¼‰
    async function testDatabasePort(port) {
        console.log(`ç«¯å£ ${port}: å¼€å§‹æ•°æ®åº“ç«¯å£æ£€æµ‹...`);

        // æ–¹æ³•1: å°è¯•TCPè¿æ¥ï¼ˆé€šè¿‡WebSocketæ¨¡æ‹Ÿï¼‰
        try {
            const ws = new WebSocket(`ws://localhost:${port}`);

            return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                    ws.close();
                    resolve({status: 'unknown'});
                }, 3000);

                ws.onopen = () => {
                    clearTimeout(timeout);
                    ws.close();
                    console.log(`ç«¯å£ ${port}: æ•°æ®åº“ç«¯å£æ£€æµ‹æˆåŠŸ (WebSocketè¿æ¥)`);
                    resolve({status: 'open'});
                };

                ws.onerror = (error) => {
                    clearTimeout(timeout);
                    console.log(`ç«¯å£ ${port}: æ•°æ®åº“ç«¯å£WebSocketæµ‹è¯•å¤±è´¥`);
                    resolve({status: 'closed'});
                };
            });

        } catch (error) {
            console.log(`ç«¯å£ ${port}: æ•°æ®åº“ç«¯å£æ£€æµ‹å¼‚å¸¸:`, error.message);
            return {status: 'unknown'};
        }
    }

    // TCPè¿æ¥æµ‹è¯•ï¼ˆå°½å¯èƒ½æ¨¡æ‹Ÿtelnetè¡Œä¸ºï¼‰
    async function testTCPConnection(port) {
        console.log(`ç«¯å£ ${port}: TCPè¿æ¥æµ‹è¯•ï¼ˆæ¨¡æ‹Ÿtelnetï¼‰...`);

        // æ–¹æ³•1: WebSocketè¿æ¥ï¼ˆæœ€æ¥è¿‘TCPï¼‰
        const wsResult = await attemptWebSocketTelnet(port);
        if (wsResult.status === 'open') {
            return wsResult;
        }

        // æ–¹æ³•2: å°è¯•WebTransportï¼ˆå¦‚æœæ”¯æŒï¼‰
        if ('WebTransport' in window) {
            const wtResult = await attemptWebTransport(port);
            if (wtResult.status === 'open') {
                return wtResult;
            }
        }

        // æ–¹æ³•3: HTTPè¿æ¥æ¢æµ‹
        const httpResult = await attemptHTTPTelnet(port);
        if (httpResult.status === 'open') {
            return httpResult;
        }

        // æ–¹æ³•4: å›¾ç‰‡åŠ è½½æ¢æµ‹ï¼ˆæ£€æµ‹HTTPæœåŠ¡ï¼‰
        const imgResult = await attemptImageTelnet(port);
        if (imgResult.status === 'open') {
            return imgResult;
        }

        return {status: 'unknown'};
    }

    // WebSocketæ¨¡æ‹Ÿtelnetè¿æ¥
    async function attemptWebSocketTelnet(port) {
        const addresses = ['localhost', '127.0.0.1', '0.0.0.0'];
        const protocols = ['ws', 'wss'];

        for (const protocol of protocols) {
            for (const address of addresses) {
                try {
                    console.log(`ç«¯å£ ${port}: å°è¯• ${protocol}://${address}:${port} (WebSocket Telnet)`);

                    const ws = new WebSocket(`${protocol}://${address}:${port}`);

                    const result = await new Promise((resolve) => {
                        const timeout = setTimeout(() => {
                            ws.close();
                            resolve({status: 'timeout'});
                        }, 3000);

                        ws.onopen = () => {
                            clearTimeout(timeout);
                            console.log(`ç«¯å£ ${port}: WebSocket telnetè¿æ¥æˆåŠŸ! (${protocol}://${address})`);

                            // å°è¯•å‘é€telnetæ¡æ‰‹
                            try {
                                ws.send('\r\n');
                            } catch (e) {
                                console.log(`ç«¯å£ ${port}: æ— æ³•å‘é€æ•°æ®ï¼Œä½†è¿æ¥æˆåŠŸ`);
                            }

                            ws.close();
                            resolve({status: 'open'});
                        };

                        ws.onerror = (error) => {
                            clearTimeout(timeout);
                            resolve({status: 'closed'});
                        };

                        ws.onclose = (event) => {
                            clearTimeout(timeout);
                            // åˆ†æå…³é—­åŸå› 
                            if (event.code === 1006) {
                                // å¼‚å¸¸å…³é—­ï¼Œå¯èƒ½æ˜¯ç«¯å£å¼€æ”¾ä½†ä¸æ˜¯WebSocketæœåŠ¡
                                console.log(`ç«¯å£ ${port}: è¿æ¥å¼‚å¸¸å…³é—­ï¼Œå¯èƒ½æ˜¯éWebSocketæœåŠ¡`);
                                resolve({status: 'open'});
                            } else {
                                resolve({status: 'closed'});
                            }
                        };
                    });

                    if (result.status === 'open') {
                        return result;
                    }

                } catch (error) {
                    console.log(`ç«¯å£ ${port}: WebSocket telnetå¼‚å¸¸ (${protocol}://${address}):`, error.message);
                    continue;
                }
            }
        }

        return {status: 'closed'};
    }

    // WebTransportè¿æ¥æµ‹è¯•ï¼ˆå®éªŒæ€§ï¼‰
    async function attemptWebTransport(port) {
        try {
            console.log(`ç«¯å£ ${port}: å°è¯• WebTransport è¿æ¥...`);

            const transport = new WebTransport(`https://localhost:${port}`);

            const result = await Promise.race([
                transport.ready.then(() => ({status: 'open'})),
                new Promise(resolve => setTimeout(() => resolve({status: 'timeout'}), 5000))
            ]);

            if (result.status === 'open') {
                console.log(`ç«¯å£ ${port}: WebTransportè¿æ¥æˆåŠŸ!`);
                transport.close();
                return result;
            }

        } catch (error) {
            console.log(`ç«¯å£ ${port}: WebTransportè¿æ¥å¤±è´¥:`, error.message);
        }

        return {status: 'closed'};
    }

    // HTTPè¿æ¥æ¢æµ‹ï¼ˆæ¨¡æ‹Ÿtelnet HTTPæ£€æµ‹ï¼‰
    async function attemptHTTPTelnet(port) {
        const protocols = ['http', 'https'];
        const addresses = ['localhost', '127.0.0.1'];

        for (const protocol of protocols) {
            for (const address of addresses) {
                try {
                    console.log(`ç«¯å£ ${port}: HTTP telnetæ¢æµ‹ ${protocol}://${address}:${port}`);

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);

                    const response = await fetch(`${protocol}://${address}:${port}`, {
                        method: 'HEAD', // ä½¿ç”¨HEADå‡å°‘æ•°æ®ä¼ è¾“
                        mode: 'no-cors',
                        signal: controller.signal,
                        cache: 'no-cache'
                    });

                    clearTimeout(timeoutId);

                    if (response.type === 'opaque' || response.ok) {
                        console.log(`ç«¯å£ ${port}: HTTP telnetæˆåŠŸ (${protocol}://${address})`);
                        return {status: 'open'};
                    }

                } catch (error) {
                    console.log(`ç«¯å£ ${port}: HTTP telnetå¤±è´¥ (${protocol}://${address}):`, error.message);

                    // åˆ†æé”™è¯¯ï¼ŒæŸäº›é”™è¯¯å¯èƒ½è¡¨ç¤ºç«¯å£å¼€æ”¾
                    if (error.message.includes('CORS') || error.message.includes('blocked')) {
                        console.log(`ç«¯å£ ${port}: CORSé”™è¯¯ï¼Œä½†ç«¯å£å¯èƒ½å¼€æ”¾`);
                        return {status: 'open'};
                    }
                }
            }
        }

        return {status: 'closed'};
    }

    // å›¾ç‰‡åŠ è½½æ¢æµ‹ï¼ˆæ£€æµ‹HTTPæœåŠ¡å“åº”ï¼‰
    async function attemptImageTelnet(port) {
        const addresses = ['localhost', '127.0.0.1'];

        for (const address of addresses) {
            try {
                console.log(`ç«¯å£ ${port}: å›¾ç‰‡telnetæ¢æµ‹ http://${address}:${port}`);

                const img = new Image();

                const result = await new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        resolve({status: 'timeout'});
                    }, 3000);

                    img.onload = () => {
                        clearTimeout(timeout);
                        console.log(`ç«¯å£ ${port}: å›¾ç‰‡telnetæˆåŠŸ (${address})`);
                        resolve({status: 'open'});
                    };

                    img.onerror = (error) => {
                        clearTimeout(timeout);
                        // 404æˆ–å…¶ä»–HTTPé”™è¯¯ä¹Ÿè¯´æ˜ç«¯å£å¼€æ”¾
                        console.log(`ç«¯å£ ${port}: å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½†å¯èƒ½æ˜¯HTTPæœåŠ¡ (${address})`);
                        resolve({status: 'unknown'});
                    };

                    // å°è¯•åŠ è½½å¸¸è§çš„ç«¯ç‚¹
                    img.src = `http://${address}:${port}/favicon.ico?_t=${Date.now()}`;
                });

                if (result.status === 'open') {
                    return result;
                }

            } catch (error) {
                console.log(`ç«¯å£ ${port}: å›¾ç‰‡telnetå¼‚å¸¸ (${address}):`, error.message);
            }
        }

        return {status: 'closed'};
    }

    // å›¾ç‰‡åŠ è½½æµ‹è¯•
    async function testImageLoad(port) {
        return new Promise((resolve) => {
            const img = new Image();
            const timeout = setTimeout(() => {
                resolve({status: 'unknown'});
            }, 2000);

            img.onload = () => {
                clearTimeout(timeout);
                console.log(`ç«¯å£ ${port}: å›¾ç‰‡åŠ è½½æˆåŠŸ`);
                resolve({status: 'open'});
            };

            img.onerror = (error) => {
                clearTimeout(timeout);
                // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯ï¼Œè¯´æ˜ç«¯å£å¯èƒ½å¼€æ”¾ä½†ä¸æ˜¯HTTPæœåŠ¡
                console.log(`ç«¯å£ ${port}: å›¾ç‰‡åŠ è½½å¤±è´¥`);
                resolve({status: 'closed'});
            };

            img.src = `http://localhost:${port}/favicon.ico?_t=${Date.now()}`;
        });
    }

    // Fetch è¿æ¥æµ‹è¯•
    async function testFetch(port) {
        try {
            const response = await fetch(`http://localhost:${port}`, {
                method: 'HEAD',
                mode: 'no-cors',
                cache: 'no-cache',
                signal: AbortSignal.timeout(2000)
            });

            console.log(`ç«¯å£ ${port}: Fetch HEADæˆåŠŸ`);
            return {status: 'open'};

        } catch (error) {
            if (error.name === 'TimeoutError') {
                return {status: 'unknown'};
            }

            console.log(`ç«¯å£ ${port}: Fetchè¿æ¥å¤±è´¥`, error.message);
            return {status: 'closed'};
        }
    }

    // è·å–WebRTCä¿¡æ¯
    function getWebRTCInfo() {
        const configuration = {
            iceServers: [
                {urls: 'stun:stun.l.google.com:19302'}
            ]
        };

        const pc = new RTCPeerConnection(configuration);
        const candidates = [];
        const localCandidates = [];

        pc.createDataChannel("");

        pc.onicecandidate = function (event) {
            if (event.candidate) {
                candidates.push(event.candidate.candidate);

                // åŒºåˆ†æœ¬åœ°å’Œè¿œç¨‹å€™é€‰
                if (event.candidate.candidate.includes('typ host')) {
                    localCandidates.push(event.candidate.candidate);
                }

                document.getElementById('iceCandidates').textContent = `${candidates.length} ä¸ª`;
                document.getElementById('iceCandidates').className = 'value-col success';

                document.getElementById('localCandidates').textContent = `${localCandidates.length} ä¸ª`;
                document.getElementById('localCandidates').className = 'value-col success';

                // è§£æç½‘ç»œæ¥å£ç±»å‹
                const interfaces = new Set();
                candidates.forEach(candidate => {
                    if (candidate.includes('typ host')) interfaces.add('Host');
                    if (candidate.includes('typ srflx')) interfaces.add('Server Reflexive');
                    if (candidate.includes('typ relay')) interfaces.add('Relay');
                    if (candidate.includes('typ prflx')) interfaces.add('Peer Reflexive');
                });

                document.getElementById('networkInterfaces').textContent = Array.from(interfaces).join(', ') || 'æ— ';
                document.getElementById('networkInterfaces').className = 'value-col success';
            }
        };

        pc.onicegatheringstatechange = function () {
            if (pc.iceGatheringState === 'complete') {
                setTimeout(() => pc.close(), 1000);
            }
        };

        pc.createOffer().then(offer => pc.setLocalDescription(offer));

        // è¶…æ—¶å¤„ç†
        setTimeout(() => {
            if (candidates.length === 0) {
                document.getElementById('iceCandidates').textContent = '-';
                document.getElementById('iceCandidates').className = 'value-col';
                document.getElementById('localCandidates').textContent = '-';
                document.getElementById('localCandidates').className = 'value-col';
                document.getElementById('networkInterfaces').textContent = '-';
                document.getElementById('networkInterfaces').className = 'value-col';
            }
            pc.close();
        }, 10000);
    }

    // åˆ·æ–°æ‰€æœ‰ä¿¡æ¯
    function refreshAllInfo() {
        // é‡ç½®åŠ è½½çŠ¶æ€
        document.querySelectorAll('.loading').forEach(el => {
            el.textContent = 'æ£€æµ‹ä¸­...';
            el.className = 'value-col loading';
        });

        // é‡ç½®æ‰€æœ‰æ˜¾ç¤ºå…ƒç´ 
        document.getElementById('publicIP').textContent = 'æ£€æµ‹ä¸­...';
        document.getElementById('publicIP').className = 'value-col loading';
        document.getElementById('localIP').textContent = 'æ£€æµ‹ä¸­...';
        document.getElementById('localIP').className = 'value-col loading';

        // æ¸…ç©ºç¼“å­˜
        localIPAddresses = [];
        publicIPInfo = {};

        // é‡æ–°æ£€æµ‹
        setTimeout(() => {
            initNetworkInfo();
        }, 500);
    }


    // æ·»åŠ é”®ç›˜å¿«æ·é”®
    document.addEventListener('keydown', function (event) {
        if (event.ctrlKey && event.key === 'r') {
            event.preventDefault();
            refreshAllInfo();
        }
    });

    // æ·»åŠ å¤åˆ¶åŠŸèƒ½
    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(function () {
            // å¯ä»¥æ·»åŠ å¤åˆ¶æˆåŠŸæç¤º
        });
    }

    // ä¸ºIPåœ°å€æ·»åŠ ç‚¹å‡»å¤åˆ¶åŠŸèƒ½
    document.addEventListener('click', function (event) {
        if (event.target.classList.contains('value-col') &&
            (event.target.id === 'localIP' || event.target.id === 'publicIP')) {
            const text = event.target.textContent;
            if (text && !text.includes('æ£€æµ‹ä¸­') && !text.includes('å¤±è´¥')) {
                copyToClipboard(text);
                const originalText = text;
                event.target.textContent = 'å·²å¤åˆ¶!';
                setTimeout(() => {
                    event.target.textContent = originalText;
                }, 1000);
            }
        }
    });

</script>
</body>
</html>
