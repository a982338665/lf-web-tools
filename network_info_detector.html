<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>网络信息检测器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 8px;
            font-size: 14px;
            overflow-x: auto;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.4em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .main-table-container {
            background: #fff;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 0;
            font-size: 0.9em;
        }

        .info-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 8px;
            text-align: left;
            font-weight: bold;
            border-bottom: 1px solid #5a6fd8;
            font-size: 0.95em;
        }

        .info-table td {
            padding: 4px 8px;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
        }

        .info-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .info-table tr:hover {
            background-color: #e3f2fd;
        }

        .info-table .label-col {
            font-weight: bold;
            color: #495057;
            width: 25%;
            background-color: rgba(102, 126, 234, 0.05);
        }

        .info-table .value-col {
            color: #007bff;
            font-family: 'Courier New', monospace;
            width: 25%;
        }

        .section-title {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            text-align: center;
            font-size: 1.0em;
            font-weight: bold;
        }

        .compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .btn-container {
            text-align: center;
            margin: 8px 0;
        }

        .footer {
            text-align: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e9ecef;
            color: #6c757d;
            font-size: 0.75em;
        }


        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .status-enabled {
            background-color: #d4edda;
            color: #155724;
        }

        .status-disabled {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status-unknown {
            background-color: #fff3cd;
            color: #856404;
        }

        .mac-address {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #28a745;
        }

        .ip-address {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #007bff;
        }

        .multi-line-ip {
            line-height: 1.6;
            word-break: break-all;
        }

        .loading {
            color: #ffc107;
        }

        .error {
            color: #dc3545;
        }

        .success {
            color: #28a745;
        }

        .refresh-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 15px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
            margin: 0 3px;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.6);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .online {
            background-color: #28a745;
        }

        .offline {
            background-color: #dc3545;
        }

        .warning {
            background-color: #ffc107;
        }

        .user-agent {
            font-size: 0.8em;
            word-break: break-all;
        }

        .port-note {
            text-align: center;
            font-size: 0.75em;
            color: #6c757d;
            padding: 8px;
        }

        @media (max-width: 768px) {
            .compact-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.3em;
                margin-bottom: 15px;
            }

            .container {
                padding: 15px;
            }

            .info-table {
                font-size: 0.85em;
            }

            .info-table th,
            .info-table td {
                padding: 5px 8px;
            }

            .refresh-btn {
                padding: 8px 20px;
                font-size: 0.85em;
                margin: 5px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 10px;
            }

            h1 {
                font-size: 1.2em;
            }

            .info-table {
                font-size: 0.8em;
            }

            .main-table-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>🌐 网络信息检测器</h1>

    <div class="btn-container">
        <button class="refresh-btn" onclick="refreshAllInfo()">🔄 刷新所有信息</button>
    </div>

    <!-- 主要网络信息表格 -->
    <div class="main-table-container">
        <table class="info-table">
            <thead>
            <tr>
                <th colspan="4" class="section-title">🌐 网络与系统信息总览</th>
            </tr>
            <tr>
                <th>IP地址信息</th>
                <th>网络状态</th>
                <th>系统信息</th>
                <th>DNS/连接信息</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td class="label-col">本地IP地址</td>
                <td class="label-col">连接状态</td>
                <td class="label-col">浏览器</td>
                <td class="label-col">DNS服务器</td>
            </tr>
            <tr>
                <td class="value-col loading" id="localIP">检测中...</td>
                <td class="value-col" id="networkStatus"><span class="status-indicator online"></span>在线</td>
                <td class="value-col" id="browser">-</td>
                <td class="value-col loading" id="dnsServers">检测中...</td>
            </tr>
            <tr>
                <td class="label-col">公网IP地址</td>
                <td class="label-col">连接类型</td>
                <td class="label-col">操作系统</td>
                <td class="label-col">DNS解析时间</td>
            </tr>
            <tr>
                <td class="value-col loading" id="publicIP">检测中...</td>
                <td class="value-col" id="connectionType">检测中...</td>
                <td class="value-col" id="platform">-</td>
                <td class="value-col loading" id="dnsTime">测试中...</td>
            </tr>
            <tr>
                <td class="label-col">网络速度</td>
                <td class="label-col">延迟</td>
                <td class="label-col">屏幕分辨率</td>
                <td class="label-col">主机名</td>
            </tr>
            <tr>
                <td class="value-col" id="networkSpeed">检测中...</td>
                <td class="value-col loading" id="latency">测试中...</td>
                <td class="value-col" id="screenRes">-</td>
                <td class="value-col" id="hostname">-</td>
            </tr>
            <tr>
                <td class="label-col">-</td>
                <td class="label-col">-</td>
                <td class="label-col">用户代理</td>
                <td class="label-col">域名</td>
            </tr>
            <tr>
                <td class="label-col">-</td>
                <td class="label-col">-</td>
                <td class="value-col user-agent" id="userAgent">-</td>
                <td class="value-col" id="domain">-</td>
            </tr>
            </tbody>
        </table>
    </div>

    <!-- 端口和WebRTC信息表格 -->
    <div class="compact-grid">
        <div class="main-table-container">
            <table class="info-table">
                <thead>
                <tr>
                    <th colspan="2" class="section-title">🔌 本地端口检测信息</th>
                </tr>
                <tr>
                    <th>端口/服务/协议</th>
                    <th>状态</th>
                </tr>
                </thead>
                <tbody id="portTableBody">
                <tr>
                    <td colspan="2" style="text-align: center; color: #ffc107;">正在检测常用端口...</td>
                </tr>
                </tbody>
            </table>
        </div>

        <div class="main-table-container">
            <table class="info-table">
                <thead>
                <tr>
                    <th colspan="2" class="section-title">🔗 WebRTC连接信息</th>
                </tr>
                <tr>
                    <th>项目</th>
                    <th>值</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td class="label-col">STUN服务器</td>
                    <td class="value-col" id="stunServer">stun.l.google.com:19302</td>
                </tr>
                <tr>
                    <td class="label-col">ICE候选</td>
                    <td class="value-col loading" id="iceCandidates">收集中...</td>
                </tr>
                <tr>
                    <td class="label-col">本地候选</td>
                    <td class="value-col loading" id="localCandidates">收集中...</td>
                </tr>
                <tr>
                    <td class="label-col">网络接口</td>
                    <td class="value-col loading" id="networkInterfaces">检测中...</td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="footer">
        <p>💡 提示：外网IP通过WebRTC STUN服务器获取，地理位置使用多个API备选查询</p>
        <p>🔒 此工具仅在本地运行，不会收集或上传任何数据</p>
        <p>⚡ 本地端口检测使用WebSocket、HTTP、Image等多种方法综合判断</p>
    </div>
</div>

<script>
    // 全局变量
    let localIPAddresses = [];
    let publicIPInfo = {};

    // 页面加载完成后初始化
    document.addEventListener('DOMContentLoaded', function () {
        initNetworkInfo();
    });

    // 初始化所有网络信息检测
    function initNetworkInfo() {
        getBrowserInfo();
        getNetworkStatus();
        getLocalIPs();  // 现在这个函数会同时获取本地IP和外网IP，并查询位置
        testLatency();
        getDNSInfo();
        checkCommonPorts();
        getWebRTCInfo();
    }

    // 获取浏览器信息
    function getBrowserInfo() {
        const userAgent = navigator.userAgent;
        document.getElementById('userAgent').textContent = userAgent;

        // 解析浏览器类型 - 改进检测顺序，优先检测特殊情况
        let browserName = "Unknown";

        // Edge 检测（新版和旧版）
        if (userAgent.indexOf("Edg/") > -1 || userAgent.indexOf("Edge/") > -1) {
            browserName = "Edge";
        }
        // Internet Explorer 检测
        else if (userAgent.indexOf("MSIE") > -1 || userAgent.indexOf("Trident/") > -1) {
            browserName = "Internet Explorer";
        }
        // Chrome 检测（需要排除Edge和其他基于Chromium的浏览器）
        else if (userAgent.indexOf("Chrome") > -1 && userAgent.indexOf("Safari") > -1) {
            browserName = "Chrome";
        }
        // Firefox 检测
        else if (userAgent.indexOf("Firefox") > -1) {
            browserName = "Firefox";
        }
        // Safari 检测（需要排除Chrome）
        else if (userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1) {
            browserName = "Safari";
        }
        // Opera 检测
        else if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) {
            browserName = "Opera";
        }

        document.getElementById('browser').textContent = browserName;
        document.getElementById('platform').textContent = navigator.platform || '-';

        // 屏幕分辨率检测
        try {
            document.getElementById('screenRes').textContent = `${screen.width} x ${screen.height}`;
        } catch (e) {
            document.getElementById('screenRes').textContent = '-';
        }
    }

    // 获取网络状态
    function getNetworkStatus() {
        // 检测在线状态
        const updateOnlineStatus = () => {
            const statusEl = document.getElementById('networkStatus');
            if (navigator.onLine) {
                statusEl.innerHTML = '<span class="status-indicator online"></span>在线';
            } else {
                statusEl.innerHTML = '<span class="status-indicator offline"></span>离线';
            }
        };

        updateOnlineStatus();
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // 获取连接类型
        if ('connection' in navigator) {
            const conn = navigator.connection;
            const connType = conn.effectiveType || conn.type || '未知';
            const downlink = conn.downlink ? `${conn.downlink} Mbps` : '未知';

            document.getElementById('connectionType').textContent = connType;
            document.getElementById('networkSpeed').textContent = downlink;
        } else {
            document.getElementById('connectionType').textContent = '浏览器不支持';
            document.getElementById('networkSpeed').textContent = '浏览器不支持';
        }
    }

    // 获取本地IP和外网IP地址（通过WebRTC）
    function getLocalIPs() {
        const configuration = {
            iceServers: [
                {urls: 'stun:stun.l.google.com:19302'},
                {urls: 'stun:stun1.l.google.com:19302'},
                {urls: 'stun:stun2.l.google.com:19302'}
            ]
        };

        const pc = new RTCPeerConnection(configuration);
        const localIps = new Set();
        const publicIps = new Set();

        pc.createDataChannel("");

        pc.onicecandidate = function (event) {
            if (event.candidate) {
                const candidate = event.candidate.candidate;
                const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
                const ipMatch = candidate.match(ipRegex);

                if (ipMatch) {
                    const ip = ipMatch[1];

                    // 区分本地IP和外网IP
                    if (candidate.includes('typ host')) {
                        // 本地网络接口IP
                        if (!ip.startsWith('127.') && !ip.startsWith('169.254.')) {
                            localIps.add(ip);
                            localIPAddresses = Array.from(localIps);
                            document.getElementById('localIP').textContent = localIPAddresses.join(', ') || '-';
                            document.getElementById('localIP').className = 'value-col success';
                        }
                    } else if (candidate.includes('typ srflx')) {
                        // STUN服务器反射的外网IP
                        publicIps.add(ip);
                        const publicIpsArray = Array.from(publicIps);

                        // 异步获取位置并格式化显示
                        updatePublicIPDisplay(publicIpsArray);
                    }
                }
            }
        };

        pc.createOffer().then(offer => pc.setLocalDescription(offer));

        // 超时处理
        setTimeout(() => {
            if (localIPAddresses.length === 0) {
                document.getElementById('localIP').textContent = '-';
                document.getElementById('localIP').className = 'value-col';
            }
            if (publicIps.size === 0) {
                // 如果WebRTC获取不到外网IP，fallback到API方式
                getPublicIPFallback();
            }
            pc.close();
        }, 8000);
    }

    // 根据IP地址获取位置信息（优先级模式）
    async function getIPLocation(ip) {
        try {
            // 使用多个API服务，按优先级顺序查询
            const apiTests = [
                // ipinfo.io - 国内不准，国外准

                // ipapi.co - 备选API，精确度较高
                {
                    name: 'ipapi.co',
                    url: `https://ipapi.co/${ip}/json/`,
                    parser: (data) => {
                        if (data.city && data.region && data.country_name) {
                            return `${data.city}, ${data.region}, ${data.country_name}`;
                        } else if (data.country_name) {
                            return data.country_name;
                        }
                        return null;
                    }
                },
                // ipgeolocation.io - 备选API
                {
                    name: 'ipgeolocation.io',
                    url: `https://api.ipgeolocation.io/v2/ipgeo?apiKey=c12f4e421c214d7ea0dbba0f34111261&ip=${ip}`,
                    parser: (data) => {
                        if (data.location.city && data.location.state_prov && data.location.country_name) {
                            return `${data.location.city}, ${data.location.state_prov}, ${data.location.country_name}`;
                        } else if (data.location.country_name) {
                            return data.location.country_name;
                        }
                        return null;
                    }
                },
                // freeipapi.com - 备选API
                {
                    name: 'freeipapi.com',
                    url: `https://free.freeipapi.com/api/json/${ip}`,
                    parser: (data) => {
                        if (data.cityName && data.regionName && data.countryName) {
                            return `${data.cityName}, ${data.regionName}, ${data.countryName}`;
                        } else if (data.countryName) {
                            return data.countryName;
                        }
                        return null;
                    }
                },
                {
                    name: 'ipinfo.io',
                    url: `https://ipinfo.io/${ip}/json`,
                    parser: (data) => {
                        if (data.city && data.region && data.country) {
                            return `${data.city}, ${data.region}, ${data.country}`;
                        } else if (data.country) {
                            return data.country;
                        }
                        return null;
                    }
                },
                // ipip.net - 国内准，国外不准
                {
                    name: 'ipip.net',
                    url: `http://myip.ipip.net`,
                    parser: (data) => {
                        return data.split("来自于：");
                    }
                },

            ];

            console.log(`开始查询IP ${ip} 的位置信息...`);

            // 按优先级顺序尝试每个API
            for (const apiTest of apiTests) {
                try {
                    console.log(`🔍 尝试 ${apiTest.name}...`);

                    const response = await fetch(apiTest.url, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-cache',
                        signal: AbortSignal.timeout(5000), // 5秒超时
                        // headers: {
                        //     'Accept': 'application/json'
                        // }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    const location = apiTest.parser(data);

                    if (location) {
                        console.log(`✅ ${apiTest.name} 成功返回位置:`, location);
                        return location;
                    } else {
                        console.log(`⚠️ ${apiTest.name} 返回数据不完整`);
                    }

                } catch (e) {
                    console.log(`❌ ${apiTest.name} 查询失败:`, e.message);
                    continue;
                }
            }

            // 如果所有API都失败
            console.warn('所有IP位置查询API都失败');
            return '位置未知';

        } catch (error) {
            console.error('IP位置查询出错:', error);
            return '位置未知';
        }
    }

    // 更新公网IP显示（包含位置信息）
    async function updatePublicIPDisplay(publicIpsArray) {
        try {
            const formattedIPs = [];

            for (const ip of publicIpsArray) {
                console.log(`\n🔍 开始查询IP ${ip} 的位置信息...`);
                const location = await getIPLocation(ip);
                formattedIPs.push(`${ip}（${location}）`);
                console.log(`✅ IP ${ip} 位置查询完成: ${location}\n`);
            }

            // 设置显示样式
            const element = document.getElementById('publicIP');
            element.style.whiteSpace = 'pre-line';
            element.textContent = formattedIPs.join('\n');
            element.className = 'value-col success multi-line-ip';

            console.log('🎉 所有IP位置查询完成！');

        } catch (error) {
            console.error('位置查询过程出错:', error);
            // 如果位置获取失败，显示不带位置的格式
            const formattedIPs = publicIpsArray.map(ip => `${ip}（位置未知）`).join('\n');
            const element = document.getElementById('publicIP');
            element.style.whiteSpace = 'pre-line';
            element.textContent = formattedIPs;
            element.className = 'value-col success multi-line-ip';
        }
    }

    // WebRTC获取不到外网IP时的后备方案
    async function getPublicIPFallback() {
        try {
            // 使用多个API服务以提高可靠性
            const apis = [
                'https://ipapi.co/json/',
                'https://ipinfo.io/json',
                'https://api.ipify.org?format=json'
            ];

            for (const api of apis) {
                try {
                    const response = await fetch(api);
                    const data = await response.json();

                    if (data.ip) {
                        // 使用统一的显示方法
                        await updatePublicIPDisplay([data.ip]);
                        publicIPInfo = data;
                        break;
                    }
                } catch (e) {
                    continue;
                }
            }

            // 如果所有API都失败
            const currentText = document.getElementById('publicIP').textContent;
            if (!currentText || currentText === '检测中...' || currentText === '-') {
                throw new Error('所有API都无法访问');
            }

        } catch (error) {
            document.getElementById('publicIP').textContent = '-';
            document.getElementById('publicIP').className = 'value-col';
        }
    }

    // 保持原有的getPublicIP函数作为兼容性接口
    async function getPublicIP() {
        // 现在主要通过WebRTC获取，这里作为后备
        return;
    }

    // 测试网络延迟
    async function testLatency() {
        try {
            const start = performance.now();
            await fetch('https://www.google.com/favicon.ico', {
                mode: 'no-cors',
                cache: 'no-cache'
            });
            const end = performance.now();
            const latency = Math.round(end - start);

            document.getElementById('latency').textContent = `${latency} ms`;
            document.getElementById('latency').className = `value-col ${latency < 100 ? 'success' : latency < 300 ? 'warning' : 'error'}`;
        } catch (error) {
            document.getElementById('latency').textContent = '-';
            document.getElementById('latency').className = 'value-col';
        }
    }

    // 获取DNS信息
    async function getDNSInfo() {
        try {
            // 测试DNS解析时间
            const start = performance.now();
            await fetch('https://www.google.com', {mode: 'no-cors'});
            const end = performance.now();
            const dnsTime = Math.round(end - start);

            document.getElementById('dnsTime').textContent = `${dnsTime} ms`;
            document.getElementById('dnsTime').className = 'value-col success';

            // 获取主机名和域名
            document.getElementById('hostname').textContent = window.location.hostname || 'localhost';
            document.getElementById('domain').textContent = window.location.host || 'file://';

            // DNS服务器（浏览器无法直接获取）
            document.getElementById('dnsServers').textContent = '-';
            document.getElementById('dnsServers').className = 'value-col';

        } catch (error) {
            document.getElementById('dnsTime').textContent = '-';
            document.getElementById('dnsTime').className = 'value-col';
            document.getElementById('dnsServers').textContent = '-';
            document.getElementById('dnsServers').className = 'value-col';
        }
    }

    // 检测本地端口（多种方法综合检测）
    async function checkCommonPorts() {
        const localPorts = [
            {port: 80, name: 'NGINX', protocol: 'HTTP/WEBSOCKET', type: 'web'},
            {port: 3000, name: 'Node.js Dev', protocol: 'HTTP/WEBSOCKET', type: 'dev'},
            {port: 5000, name: 'Flask/Dev', protocol: 'HTTP/WEBSOCKET', type: 'dev'},
            {port: 8000, name: 'Python HTTP', protocol: 'HTTP/WEBSOCKET', type: 'dev'},
            {port: 8080, name: 'HTTP-Alt', protocol: 'HTTP/WEBSOCKET', type: 'web'},
            {port: 9000, name: 'Dev Server', protocol: 'HTTP/WEBSOCKET', type: 'dev'},
        ];

        const portTableBody = document.getElementById('portTableBody');
        portTableBody.innerHTML = '';

        // 创建初始行，显示检测状态
        localPorts.forEach(portInfo => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="label-col">端口 ${portInfo.port} (${portInfo.name}/${portInfo.protocol})</td>
                <td class="value-col loading" id="port_${portInfo.port}">检测中...</td>
            `;
            portTableBody.appendChild(row);
        });

        console.log('🚀 开始检测本地端口状态...');
        console.log('💡 提示：请打开浏览器开发者工具(F12)查看详细检测过程');

        // 并行检测所有端口
        const promises = localPorts.map(async (portInfo) => {
            const result = await detectLocalPort(portInfo.port, portInfo.protocol, portInfo.type);
            const element = document.getElementById(`port_${portInfo.port}`);

            if (result.status === 'open') {
                const protocolInfo = result.protocol ? `(${result.protocol})` : '';
                element.innerHTML = `<span class="status-indicator online"></span>${result.method}检测到开放 ${protocolInfo}`;
                element.className = 'value-col success';
            } else if (result.status === 'closed') {
                element.innerHTML = `<span class="status-indicator offline"></span>关闭`;
                element.className = 'value-col error';
            } else {
                element.textContent = '-';
                element.className = 'value-col';
            }
        });

        // 等待所有检测完成
        await Promise.allSettled(promises);

        // 添加说明行
        const noteRow = document.createElement('tr');
        noteRow.innerHTML = `
            <td colspan="2" class="port-note">
                💡 使用WebSocket、HTTP、Image等方法检测本地端口 | 🟢开放 🔴关闭 - 无法确定<br>
                🔧 如果检测结果不准确，请按F12查看控制台详细日志，或尝试刷新页面
            </td>
        `;
        portTableBody.appendChild(noteRow);
    }

    // 检测本地端口状态（综合多种方法）
    async function detectLocalPort(port, protocol, type) {
        console.log(`🔍 检测本地端口 ${port} (${protocol}, 类型: ${type})...`);

        // 对于web和dev类型的端口，优先使用HTTP检测
        if (type === 'web' || type === 'dev') {
            console.log(`端口 ${port}: 优先使用HTTP检测...`);
            const httpResult = await testHTTP(port);
            if (httpResult.status === 'open') {
                console.log(`✅ 端口 ${port}: HTTP检测成功!`);
                return {
                    status: httpResult.status,
                    method: 'HTTP',
                    protocol: httpResult.protocol
                };
            } else if (httpResult.status === 'closed') {
                console.log(`❌ 端口 ${port}: HTTP检测确认关闭`);
                return {status: httpResult.status, method: 'HTTP'};
            }
        }

        // 方法1: WebSocket 连接测试
        console.log(`端口 ${port}: 尝试WebSocket检测...`);
        const wsResult = await testWebSocket(port);
        if (wsResult.status === 'open') {
            console.log(`✅ 端口 ${port}: WebSocket检测成功!`);
            return {status: wsResult.status, method: 'WebSocket'};
        }

        // 方法2: 原始TCP连接测试
        console.log(`端口 ${port}: 尝试TCP连接检测...`);
        const tcpResult = await testTCPConnection(port);
        if (tcpResult.status === 'open') {
            console.log(`✅ 端口 ${port}: TCP连接检测成功!`);
            return {status: tcpResult.status, method: 'TCP'};
        }

        // 方法3: 图片加载测试（适用于HTTP服务）
        console.log(`端口 ${port}: 尝试Image加载检测...`);
        const imgResult = await testImageLoad(port);
        if (imgResult.status === 'open') {
            console.log(`✅ 端口 ${port}: Image检测成功!`);
            return {status: imgResult.status, method: 'Image'};
        }

        // 方法4: Fetch连接测试
        console.log(`端口 ${port}: 尝试Fetch检测...`);
        const fetchResult = await testFetch(port);
        if (fetchResult.status === 'open') {
            console.log(`✅ 端口 ${port}: Fetch检测成功!`);
            return {status: fetchResult.status, method: 'Fetch'};
        }

        // 如果有任何方法明确返回关闭，则认为关闭
        if (wsResult.status === 'closed' || tcpResult.status === 'closed' ||
            imgResult.status === 'closed' || fetchResult.status === 'closed') {
            console.log(`❌ 端口 ${port}: 多种方法确认端口关闭`);
            return {status: 'closed', method: 'Multiple'};
        }

        console.log(`⚠️ 端口 ${port}: 所有检测方法都无法确定状态`);
        return {status: 'unknown', method: 'Unknown'};
    }

    // WebSocket 连接测试
    async function testWebSocket(port) {
        return new Promise((resolve) => {
            try {
                const ws = new WebSocket(`ws://localhost:${port}`);

                const timeout = setTimeout(() => {
                    ws.close();
                    resolve({status: 'unknown'});
                }, 3000);

                ws.onopen = () => {
                    clearTimeout(timeout);
                    ws.close();
                    console.log(`端口 ${port}: WebSocket连接成功`);
                    resolve({status: 'open'});
                };

                ws.onerror = (error) => {
                    clearTimeout(timeout);
                    console.log(`端口 ${port}: WebSocket连接失败`);
                    resolve({status: 'closed'});
                };

            } catch (error) {
                console.log(`端口 ${port}: WebSocket测试异常`);
                resolve({status: 'unknown'});
            }
        });
    }

    // HTTP 请求测试（同时尝试HTTP和HTTPS）
    async function testHTTP(port) {
        // 先尝试HTTP
        const httpResult = await testSingleHTTP(port, 'http');
        if (httpResult.status === 'open') {
            return {status: 'open', protocol: 'HTTP'};
        }
        // 再尝试HTTPS
        const httpsResult = await testSingleHTTP(port, 'https');
        if (httpsResult.status === 'open') {
            return {status: 'open', protocol: 'HTTPS'};
        }

        // 如果两个都失败，返回较明确的结果
        if (httpResult.status === 'closed' || httpsResult.status === 'closed') {
            return {status: 'closed'};
        }

        return {status: 'unknown'};
    }

    // 单个协议的HTTP测试
    async function testSingleHTTP(port, protocol) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 8000); // 增加到8秒

            // 尝试多个地址：localhost 和 127.0.0.1
            const addresses = ['localhost', '127.0.0.1'];

            for (const address of addresses) {
                try {
                    console.log(`端口 ${port}: 尝试 ${protocol}://${address}:${port}`);
                    const response = await fetch(`${protocol}://${address}:${port}`, {
                        method: 'GET',
                        mode: 'no-cors', // no-cors模式下，成功请求不会抛出异常
                        signal: controller.signal,
                        cache: 'no-cache'
                    });
                    clearTimeout(timeoutId);

                    console.log(`端口 ${port}: ${protocol.toUpperCase()}请求成功 (${address})，状态:`, response.type);
                    // no-cors模式下，如果请求成功，response.type会是'opaque'

                    if (response.type === 'opaque' || response.ok) {
                        return {status: 'open'};
                    }
                } catch (addrError) {
                    console.log(`端口 ${port}: ${protocol.toUpperCase()} ${address} 失败:`, addrError.message);
                    continue; // 尝试下一个地址
                }
            }

            clearTimeout(timeoutId);
            return {status: 'unknown'};

        } catch (error) {
            console.log(`端口 ${port}: ${protocol.toUpperCase()}请求异常:`, error.name, error.message);

            if (error.name === 'AbortError') {
                console.log(`端口 ${port}: ${protocol.toUpperCase()}请求超时`);
                return {status: 'unknown'};
            }

            // 更精确的错误分析
            const errorMessage = error.message.toLowerCase();

            if (errorMessage.includes('connection refused') ||
                errorMessage.includes('connection reset') ||
                errorMessage.includes('network error') ||
                errorMessage.includes('failed to fetch')) {

                // 进一步区分是端口关闭还是其他网络问题
                if (errorMessage.includes('refused')) {
                    console.log(`端口 ${port}: ${protocol.toUpperCase()}连接被拒绝 - 端口关闭`);
                    return {status: 'closed'};
                } else {
                    console.log(`端口 ${port}: ${protocol.toUpperCase()}网络错误 - 状态未知`);
                    return {status: 'unknown'};
                }
            }

            // 对于其他类型的错误，认为是端口相关问题
            console.log(`端口 ${port}: ${protocol.toUpperCase()}其他错误，可能端口关闭`);
            return {status: 'closed'};
        }
    }

    // 数据库端口检测（专用于MySQL、PostgreSQL等）
    async function testDatabasePort(port) {
        console.log(`端口 ${port}: 开始数据库端口检测...`);

        // 方法1: 尝试TCP连接（通过WebSocket模拟）
        try {
            const ws = new WebSocket(`ws://localhost:${port}`);

            return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                    ws.close();
                    resolve({status: 'unknown'});
                }, 3000);

                ws.onopen = () => {
                    clearTimeout(timeout);
                    ws.close();
                    console.log(`端口 ${port}: 数据库端口检测成功 (WebSocket连接)`);
                    resolve({status: 'open'});
                };

                ws.onerror = (error) => {
                    clearTimeout(timeout);
                    console.log(`端口 ${port}: 数据库端口WebSocket测试失败`);
                    resolve({status: 'closed'});
                };
            });

        } catch (error) {
            console.log(`端口 ${port}: 数据库端口检测异常:`, error.message);
            return {status: 'unknown'};
        }
    }

    // TCP连接测试（尽可能模拟telnet行为）
    async function testTCPConnection(port) {
        console.log(`端口 ${port}: TCP连接测试（模拟telnet）...`);

        // 方法1: WebSocket连接（最接近TCP）
        const wsResult = await attemptWebSocketTelnet(port);
        if (wsResult.status === 'open') {
            return wsResult;
        }

        // 方法2: 尝试WebTransport（如果支持）
        if ('WebTransport' in window) {
            const wtResult = await attemptWebTransport(port);
            if (wtResult.status === 'open') {
                return wtResult;
            }
        }

        // 方法3: HTTP连接探测
        const httpResult = await attemptHTTPTelnet(port);
        if (httpResult.status === 'open') {
            return httpResult;
        }

        // 方法4: 图片加载探测（检测HTTP服务）
        const imgResult = await attemptImageTelnet(port);
        if (imgResult.status === 'open') {
            return imgResult;
        }

        return {status: 'unknown'};
    }

    // WebSocket模拟telnet连接
    async function attemptWebSocketTelnet(port) {
        const addresses = ['localhost', '127.0.0.1', '0.0.0.0'];
        const protocols = ['ws', 'wss'];

        for (const protocol of protocols) {
            for (const address of addresses) {
                try {
                    console.log(`端口 ${port}: 尝试 ${protocol}://${address}:${port} (WebSocket Telnet)`);

                    const ws = new WebSocket(`${protocol}://${address}:${port}`);

                    const result = await new Promise((resolve) => {
                        const timeout = setTimeout(() => {
                            ws.close();
                            resolve({status: 'timeout'});
                        }, 3000);

                        ws.onopen = () => {
                            clearTimeout(timeout);
                            console.log(`端口 ${port}: WebSocket telnet连接成功! (${protocol}://${address})`);

                            // 尝试发送telnet握手
                            try {
                                ws.send('\r\n');
                            } catch (e) {
                                console.log(`端口 ${port}: 无法发送数据，但连接成功`);
                            }

                            ws.close();
                            resolve({status: 'open'});
                        };

                        ws.onerror = (error) => {
                            clearTimeout(timeout);
                            resolve({status: 'closed'});
                        };

                        ws.onclose = (event) => {
                            clearTimeout(timeout);
                            // 分析关闭原因
                            if (event.code === 1006) {
                                // 异常关闭，可能是端口开放但不是WebSocket服务
                                console.log(`端口 ${port}: 连接异常关闭，可能是非WebSocket服务`);
                                resolve({status: 'open'});
                            } else {
                                resolve({status: 'closed'});
                            }
                        };
                    });

                    if (result.status === 'open') {
                        return result;
                    }

                } catch (error) {
                    console.log(`端口 ${port}: WebSocket telnet异常 (${protocol}://${address}):`, error.message);
                    continue;
                }
            }
        }

        return {status: 'closed'};
    }

    // WebTransport连接测试（实验性）
    async function attemptWebTransport(port) {
        try {
            console.log(`端口 ${port}: 尝试 WebTransport 连接...`);

            const transport = new WebTransport(`https://localhost:${port}`);

            const result = await Promise.race([
                transport.ready.then(() => ({status: 'open'})),
                new Promise(resolve => setTimeout(() => resolve({status: 'timeout'}), 5000))
            ]);

            if (result.status === 'open') {
                console.log(`端口 ${port}: WebTransport连接成功!`);
                transport.close();
                return result;
            }

        } catch (error) {
            console.log(`端口 ${port}: WebTransport连接失败:`, error.message);
        }

        return {status: 'closed'};
    }

    // HTTP连接探测（模拟telnet HTTP检测）
    async function attemptHTTPTelnet(port) {
        const protocols = ['http', 'https'];
        const addresses = ['localhost', '127.0.0.1'];

        for (const protocol of protocols) {
            for (const address of addresses) {
                try {
                    console.log(`端口 ${port}: HTTP telnet探测 ${protocol}://${address}:${port}`);

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);

                    const response = await fetch(`${protocol}://${address}:${port}`, {
                        method: 'HEAD', // 使用HEAD减少数据传输
                        mode: 'no-cors',
                        signal: controller.signal,
                        cache: 'no-cache'
                    });

                    clearTimeout(timeoutId);

                    if (response.type === 'opaque' || response.ok) {
                        console.log(`端口 ${port}: HTTP telnet成功 (${protocol}://${address})`);
                        return {status: 'open'};
                    }

                } catch (error) {
                    console.log(`端口 ${port}: HTTP telnet失败 (${protocol}://${address}):`, error.message);

                    // 分析错误，某些错误可能表示端口开放
                    if (error.message.includes('CORS') || error.message.includes('blocked')) {
                        console.log(`端口 ${port}: CORS错误，但端口可能开放`);
                        return {status: 'open'};
                    }
                }
            }
        }

        return {status: 'closed'};
    }

    // 图片加载探测（检测HTTP服务响应）
    async function attemptImageTelnet(port) {
        const addresses = ['localhost', '127.0.0.1'];

        for (const address of addresses) {
            try {
                console.log(`端口 ${port}: 图片telnet探测 http://${address}:${port}`);

                const img = new Image();

                const result = await new Promise((resolve) => {
                    const timeout = setTimeout(() => {
                        resolve({status: 'timeout'});
                    }, 3000);

                    img.onload = () => {
                        clearTimeout(timeout);
                        console.log(`端口 ${port}: 图片telnet成功 (${address})`);
                        resolve({status: 'open'});
                    };

                    img.onerror = (error) => {
                        clearTimeout(timeout);
                        // 404或其他HTTP错误也说明端口开放
                        console.log(`端口 ${port}: 图片加载失败，但可能是HTTP服务 (${address})`);
                        resolve({status: 'unknown'});
                    };

                    // 尝试加载常见的端点
                    img.src = `http://${address}:${port}/favicon.ico?_t=${Date.now()}`;
                });

                if (result.status === 'open') {
                    return result;
                }

            } catch (error) {
                console.log(`端口 ${port}: 图片telnet异常 (${address}):`, error.message);
            }
        }

        return {status: 'closed'};
    }

    // 图片加载测试
    async function testImageLoad(port) {
        return new Promise((resolve) => {
            const img = new Image();
            const timeout = setTimeout(() => {
                resolve({status: 'unknown'});
            }, 2000);

            img.onload = () => {
                clearTimeout(timeout);
                console.log(`端口 ${port}: 图片加载成功`);
                resolve({status: 'open'});
            };

            img.onerror = (error) => {
                clearTimeout(timeout);
                // 如果是网络错误，说明端口可能开放但不是HTTP服务
                console.log(`端口 ${port}: 图片加载失败`);
                resolve({status: 'closed'});
            };

            img.src = `http://localhost:${port}/favicon.ico?_t=${Date.now()}`;
        });
    }

    // Fetch 连接测试
    async function testFetch(port) {
        try {
            const response = await fetch(`http://localhost:${port}`, {
                method: 'HEAD',
                mode: 'no-cors',
                cache: 'no-cache',
                signal: AbortSignal.timeout(2000)
            });

            console.log(`端口 ${port}: Fetch HEAD成功`);
            return {status: 'open'};

        } catch (error) {
            if (error.name === 'TimeoutError') {
                return {status: 'unknown'};
            }

            console.log(`端口 ${port}: Fetch连接失败`, error.message);
            return {status: 'closed'};
        }
    }

    // 获取WebRTC信息
    function getWebRTCInfo() {
        const configuration = {
            iceServers: [
                {urls: 'stun:stun.l.google.com:19302'}
            ]
        };

        const pc = new RTCPeerConnection(configuration);
        const candidates = [];
        const localCandidates = [];

        pc.createDataChannel("");

        pc.onicecandidate = function (event) {
            if (event.candidate) {
                candidates.push(event.candidate.candidate);

                // 区分本地和远程候选
                if (event.candidate.candidate.includes('typ host')) {
                    localCandidates.push(event.candidate.candidate);
                }

                document.getElementById('iceCandidates').textContent = `${candidates.length} 个`;
                document.getElementById('iceCandidates').className = 'value-col success';

                document.getElementById('localCandidates').textContent = `${localCandidates.length} 个`;
                document.getElementById('localCandidates').className = 'value-col success';

                // 解析网络接口类型
                const interfaces = new Set();
                candidates.forEach(candidate => {
                    if (candidate.includes('typ host')) interfaces.add('Host');
                    if (candidate.includes('typ srflx')) interfaces.add('Server Reflexive');
                    if (candidate.includes('typ relay')) interfaces.add('Relay');
                    if (candidate.includes('typ prflx')) interfaces.add('Peer Reflexive');
                });

                document.getElementById('networkInterfaces').textContent = Array.from(interfaces).join(', ') || '无';
                document.getElementById('networkInterfaces').className = 'value-col success';
            }
        };

        pc.onicegatheringstatechange = function () {
            if (pc.iceGatheringState === 'complete') {
                setTimeout(() => pc.close(), 1000);
            }
        };

        pc.createOffer().then(offer => pc.setLocalDescription(offer));

        // 超时处理
        setTimeout(() => {
            if (candidates.length === 0) {
                document.getElementById('iceCandidates').textContent = '-';
                document.getElementById('iceCandidates').className = 'value-col';
                document.getElementById('localCandidates').textContent = '-';
                document.getElementById('localCandidates').className = 'value-col';
                document.getElementById('networkInterfaces').textContent = '-';
                document.getElementById('networkInterfaces').className = 'value-col';
            }
            pc.close();
        }, 10000);
    }

    // 刷新所有信息
    function refreshAllInfo() {
        // 重置加载状态
        document.querySelectorAll('.loading').forEach(el => {
            el.textContent = '检测中...';
            el.className = 'value-col loading';
        });

        // 重置所有显示元素
        document.getElementById('publicIP').textContent = '检测中...';
        document.getElementById('publicIP').className = 'value-col loading';
        document.getElementById('localIP').textContent = '检测中...';
        document.getElementById('localIP').className = 'value-col loading';

        // 清空缓存
        localIPAddresses = [];
        publicIPInfo = {};

        // 重新检测
        setTimeout(() => {
            initNetworkInfo();
        }, 500);
    }


    // 添加键盘快捷键
    document.addEventListener('keydown', function (event) {
        if (event.ctrlKey && event.key === 'r') {
            event.preventDefault();
            refreshAllInfo();
        }
    });

    // 添加复制功能
    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(function () {
            // 可以添加复制成功提示
        });
    }

    // 为IP地址添加点击复制功能
    document.addEventListener('click', function (event) {
        if (event.target.classList.contains('value-col') &&
            (event.target.id === 'localIP' || event.target.id === 'publicIP')) {
            const text = event.target.textContent;
            if (text && !text.includes('检测中') && !text.includes('失败')) {
                copyToClipboard(text);
                const originalText = text;
                event.target.textContent = '已复制!';
                setTimeout(() => {
                    event.target.textContent = originalText;
                }, 1000);
            }
        }
    });

</script>
</body>
</html>
